# トランザクション管理
ここでは, トランザクション管理としてトランザクションとは何か, ACID特性, 同時実行制御, 障害回復管理, 問い合わせの効率化の5つについて述べる.

## トランザクションとは
DBMSは複数の利用者が同時にデータベースにアクセスしてもデータの矛盾を発生させない仕組みを備えている. この仕組みをトランザクション管理といい, それを行うためのSQL処理単位をトランザクションという.

## ACID特性
トランザクション処理が備えているべき4つの特性をACID特性という. 4つの特性を次に示す.
- 原始性(Atomicity) : 更新処理トランザクションが正常終了した場合にのみデータベースへの反映を保証(commit)し, 異常終了した場合には何もなかった状態に戻す(rollback)こと

- 一貫性(Consistency) : トランザクションの処理によってデータベース内に矛盾が生じない, 整合性が保たれた状態であること

- 隔離性(Isolation) : 複数のトランザクションを同時に実行したときと, 直列に実行したときで処理結果が一致すること

- 耐久性(Durability) : いったん正常終了したトランザクションの結果は, その後障害が発生してもデータベースから消失しないこと

## 同時実行制御
複数のトランザクションを同時に実行しても矛盾を起こすことなく処理が実行されるメカニズムを同時実行制御という. これを実現する方法として, ロック, 多版同時実行制御, 時刻印アルゴリズムがある. ここではこれら3つの方法について説明する.

### ロック
トランザクションTR1, TR2が同じデータaを同時に読み込み, TR1がa←a+5して, TR2がa←a+10して戻したとき, 最終的にaは15となりTR1の更新内容が失われてしまう(変更消失). この問題を防ぐ方法として, データにロックをかけて, 先にデータにアクセスしたトランザクションの処理が終了する, あるいはロックが解除されるまで他のトランザクションを待たせるという制御方法が考えられる.  
### デッドロック
ロックを複数のデータに対して行おうとすると, 互いにロックの解除を待ち続けるデッドロック状態に陥ることが考えられる. このような場合, ロールバックなどによって1つのトランザクションを強制終了させることでデッドロックを解除することができる.   
### ロック方式
ロック方式には2相ロック方式と木制約がある. 2相ロック方式は使用するデータに対して一斉にロックをかけ(1相目), 処理後に一斉にロックを解除する(2相目)という方式である. この方式では直列可能性は保証されるがデッドロック発生の可能性は残っている. 一方で木制約はデータに順番をつけ, その順番通りにロックをかけていくことでデッドロックがない, さらに直列可能性を保証する方式である. データへの順番付けには木(方向木)を用いる.   
### ロックの種類
ロックには占有ロックと共有ロックがある. 占有ロックはデータ更新を行うときに用いるロックで他のトランザクションからのアクセスは一切禁止される. 一方で共有ロックは通常データ読み込み時に使用されるロックで参照のみを許可する. 
### ロックの粒度
ロックは表, ブロック, 行といった単位でかけることができる. これをロックの粒度という. 粒度が小さければ同時実行性が高まるが, ロック回数が多くなりオーバヘッドが増加する. 一方でロック粒度が大きければトランザクション管理は容易になるが, ロック解除待ちが長くなり ,同時実行性が低下する.

### 多版同時実行制御
多版同時実行制御(MVCC;MultiVersion Concurrency Control)とは同時実行性を高め, かつ一貫性のあるトランザクション処理を実現する仕組みである. 通常占有ロック中はデータに対する参照を行えないが, MVCCでは更新中のデータに参照要求を行った場合は更新前のデータ内容が返されるため後続トランザクションを待たずに処理を行うことができる.

### 時刻印アルゴリズム
ロック制御を行わず同時実行制御を行う方法に時刻印(タイムスタンプ)アルゴリズムがある. これはトランザクションが発生した時刻Tとデータの持つ読み込み時間Tr, あるいは書き込み時間Twとを比較して読み書きの判断を行う方法である. 読み込みの場合, Tw≦Tのときのみ読み込み処理を行い, 読み取った後に読み込み時刻Trにトランザクション発生時刻Tを設定する. 書き込みの場合

## 障害回復管理
データベースには次のような障害が発生することが考えられる.
- 記憶媒体の故障(媒体故障)
- DBMS, OSのバグやオペレータの誤操作によるシステムダウン(システム障害)
- プログラムのバグ, デッドロックの発生によるトランザクションの強制終了, 異常終了(トランザクション障害)

これらの障害からデータベースを復旧し, 一貫性が保たれた状態に戻す障害回復を行うためには次のファイルを事前に取得しておく必要がある.
- ログファイル : トランザクション処理によってDBに対して更新が行われると更新前・更新後の履歴であるログファイルが記録される.
- バックアップファイル : 媒体障害に備えてDBとログファイルを定期的に別の媒体に退避しておく. DBのバックアップは定期的に行われるがログファイルのバックアップはログファイル切り替え時に行う. 

### 媒体障害からの回復
媒体障害が発生したときには, バックアップファイルとログファイルの更新後ログを用いてロールフォワード処理を行ってDBの回復処理を行う. 例えば, 時刻T1でバックアップファイルを作成し, 時刻T2で媒体障害が発生したとき, まずバックアップファイルを用いて時刻T1の状態に回復する. その後でログファイルを用いてロールフォワード処理を行い, T2までの時刻のレコードを再現する.  
### トランザクション障害からの回復
トランザクションが異常終了した場合は, ログファイルの更新前ログを用いてロールバック処理を実行し, トランザクションの実行前に戻す処理を行う. 
### システム障害からの回復
現在のDBMSでは, ディスクの入出力効率向上のために, データとログをメモリ上にバッファリングしておき, データの更新はひとまずこのデータベースバッファに対して行っておいて, ある時点(チェックポイント)でデータベースへ書き出す方式を採用している. チェックポイントの発生はトランザクションのcommitとは非同期である. このようなチェックポイントを設けることでそれまで行われてきた処理内容が全てデータベースに書き出されるため, システム障害が発生したときは障害回復を開始すべき時点, すなわちチェックポイントまで戻りそこからロールバック処理やロールフォワード処理を行うだけで回復が行える. これらをまとめるとシステム障害からの回復手順は次の通りである. この回復処理をチェックポイントリスタートやウォームスタートという.

1. 障害発生時点からチェックポイントまで逆方向にログファイルを見ていき, コミットされていないトランザクションを更新前ログを用いてロールバックする.
2. チェックポイントから障害発生時点まで正方向にログファイルを見ていきコミット完了済みのトランザクションを更新後ログファイルを用いてロールフォワードする.

## 問合せ処理の効率化
ここでは問合せ処理を効率化する方法について述べる.  
### インデックス
データベースへのアクセス効率を向上させるためにインデックスを用いる. 一般にwhere句に指定する問合せ条件や, order by句, group by句で頻繁に使用されるデータ列にインデックスを付与することで処理速度の向上が期待できる. インデックスの方式にはB+木インデックス, ビットマップインデックス, ハッシュインデックスの3つがある.

### B+木インデックス
B+木インデックスは現在, DBMSで最も多く使われているインデックスである. B木を拡張したB+木を用いて, 節にキー値と部分木へのポインタ, 葉にはデータを格納する構造となっている. B+木インデックスには次のような特徴がある.

- 値一致検索だけでなく範囲検索に優れている.
- 最下位索引部同士をポインタで結ぶことで順次検索も高速化している.
- データの追加・削除に伴って必要な場合はブロックの分割や併合を行う．
- 1件のデータを検索するときの節へのアクセス回数は木の深さに比例するため, 索引部の節に多くのキー値を持たせることで木の深さが浅くなり効率化される.

### ビットマップインデックス
ビットマップインデックスはインデックスを付与する列のデータ値ごとにビットマップを作る方式である. この方法はデータ量に比べてデータ値の種類が少ない場合に有用である.

### ハッシュインデックス
ハッシュを用いてキー値とデータを直接関係づける方式で, 一意検索に優れているが全件検索や範囲検索に不向きであるという特徴がある.

## 複合インデックス
複数の列を組み合わせて1つのインデックスとする方法を複合インデックスという. 「where A='aaa' and B= 'bbb'」という検索条件が頻繁に用いられる場合に複合インデックスを用いることで検索を高速化することができる.

## オプティマイザ
RDBMSにはSQL文を実行するときに問合せをどのように処理するかを決めるクエリ最適化の機能オプティマイザがある. オプティマイザにはコストベースとルールベースの2つがある. コストベースのオプティマイザではディスクファイルのI/Oや入出力バッファ, ログバッファの使用回数の統計情報をもとに表へのアクセスや表の結合にかかるI/Oなどを見積り, 最適なアクセス方法と結合順序を選択する. ルールベースのオプティマイザでは, 実行するSQL文を分解し, その分解された情報と所定のルールによってアクセス方法を選択する. 

## データベースのチューニング
データベースシステムにおいて, アクセス性能の確保が重要である. 性能低下が目立ってきた場合, 適切なチューニングを実施する必要がある. チューニングの方法としては, 複数ディスクへの分割や, 表の分割, データベースの再編成が考えられる.